% rho_distance.m
%
% Generate plots for the various Rho values based upon the distance from
% the centeroid of the district and the frequency of movements.
addpath('Shared');
clear;

% Note the constants
global PROVINCES;
PROVINCES = { 
    14, 67.60, 'Kadiogo'; 
    16, 41.13, 'Kourweogo'; 
    21, 73.25, 'Bazega' };

% Load the distance data, convert zero- to one-indexed
global distance;
distance = csvread('Shared/marshall_survey_centroid.csv', 1, 0);
distance(:, 2) = distance(:, 2) + 1;
distance(:, 3) = distance(:, 3) + 1;

generate_plots('data/model-rho-sweep.csv');

% Generate plots that compare the model output for each rho value to the
% expected movement data based upon the survey.
function [] = generate_plots(filename) 
    global PROVINCES; global distance;

    % Make sure the output path exists
    if ~exist('out', 'dir'), mkdir('out'); end
    
    % Load the survey data
    survey = load_survey();

    % Load the rho sweep
    raw = csvread(filename, 1, 0);

    for rho = transpose(unique(raw(:, 1)))        
        working = raw(raw(:, 1) == rho, :);

        fig = figure("Visible", "off");
        set(0, "CurrentFigure", fig);
        set(fig, "Position", [0, 0, 1500, 1500]);

        for id = 1:3
            results = zeros(2, 46);
            data = working(working(:, 2) == PROVINCES{id, 1}, :);

            for ndx = 1:45
                % Note the count
                results(1, ndx + 1) = data(data(:, 3) == ndx, 4);

                % Note the distance
                temp = distance(distance(:, 2) == PROVINCES{id, 1}, :);
                temp = temp(temp(:, 3) == ndx, :);
                if ~isempty(temp)
                    results(2, ndx + 1) = temp(1, 6);
                else
                    results(2, ndx + 1) = PROVINCES{id, 2} / 2;
                end
            end

            % Sort by distance
            results = transpose(sortrows(transpose(results), 2));

            % Calculate the frequency
            results(1, :) = results(1, :) / sum(results(1, :));

            % Plot
            subplot(3, 1, id);
            hold on;
            plot(results(2, :), log10(results(1, :) * 100), 'b-', 'LineWidth', 2);
            plot(survey((id + 1) + 1 * (id - 1), :), log10(survey(id + 1 * (id - 1), :) * 100), 'ro-', 'LineWidth', 2);
            hold off;

            % Add the plot information
            title(sprintf('Departing from %s', PROVINCES{id, 3}));
            if id == 3
                xlabel('Distance (km)'); 
            end
            if id == 1
                legend('Model', 'Survey');
                legend boxoff;
            end

            % Change the ticks for the log10 so they are easier to interperate
            set(gca, 'YTick', [ 0 0.3 1 1.3 2 ]);
            set(gca, 'YTickLabel', { '1', '5', '10', '50', '100' })
            axis([0 500 -1 2 ]);
            ylabel('Frequency (%)');  
            graphic = gca;
            graphic.FontSize = 18;
        end

%        sgtitle(sprintf('Synthetic Survey of Trips Generated by Model, log_{10}(rho) = %.2f', rho));
        exportgraphics(fig, sprintf('out/frequency-rho-%.2f.png', rho), 'Resolution', 300);
        close(fig);
    end
end

function [survey] = load_survey() 
    global PROVINCES; global distance;
    
    survey = [];
    for id = 1:3
        provience = zeros(2, 46);
        provience(1, 2:end) = getSurveyPoints(PROVINCES{id, 1});
        for ndx = 1:45
            % Note the distance
            temp = distance(distance(:, 2) == PROVINCES{id, 1}, :);
            temp = temp(temp(:, 3) == ndx, :);
            if ~isempty(temp)
                provience(2, ndx + 1) = temp(1, 6);
            else
                provience(2, ndx + 1) = PROVINCES{id, 2} / 2;
            end
        end
        provience = transpose(sortrows(transpose(provience), 2));
        provience(1, :) = provience(1, :) / sum(provience(1, :));
        survey = [survey; provience];
    end
end